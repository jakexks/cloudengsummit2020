// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeType struct {
	ApiVersion *string           `pulumi:"apiVersion"`
	Kind       *string           `pulumi:"kind"`
	Metadata   metav1.ObjectMeta `pulumi:"metadata"`
	Spec       ChallengeSpec     `pulumi:"spec"`
	Status     *ChallengeStatus  `pulumi:"status"`
}

// ChallengeTypeInput is an input type that accepts ChallengeTypeArgs and ChallengeTypeOutput values.
// You can construct a concrete instance of `ChallengeTypeInput` via:
//
//          ChallengeTypeArgs{...}
type ChallengeTypeInput interface {
	pulumi.Input

	ToChallengeTypeOutput() ChallengeTypeOutput
	ToChallengeTypeOutputWithContext(context.Context) ChallengeTypeOutput
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeTypeArgs struct {
	ApiVersion pulumi.StringPtrInput   `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput   `pulumi:"kind"`
	Metadata   metav1.ObjectMetaInput  `pulumi:"metadata"`
	Spec       ChallengeSpecInput      `pulumi:"spec"`
	Status     ChallengeStatusPtrInput `pulumi:"status"`
}

func (ChallengeTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeType)(nil)).Elem()
}

func (i ChallengeTypeArgs) ToChallengeTypeOutput() ChallengeTypeOutput {
	return i.ToChallengeTypeOutputWithContext(context.Background())
}

func (i ChallengeTypeArgs) ToChallengeTypeOutputWithContext(ctx context.Context) ChallengeTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeTypeOutput)
}

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeTypeOutput struct{ *pulumi.OutputState }

func (ChallengeTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeType)(nil)).Elem()
}

func (o ChallengeTypeOutput) ToChallengeTypeOutput() ChallengeTypeOutput {
	return o
}

func (o ChallengeTypeOutput) ToChallengeTypeOutputWithContext(ctx context.Context) ChallengeTypeOutput {
	return o
}

func (o ChallengeTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o ChallengeTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o ChallengeTypeOutput) Metadata() metav1.ObjectMetaOutput {
	return o.ApplyT(func(v ChallengeType) metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaOutput)
}

func (o ChallengeTypeOutput) Spec() ChallengeSpecOutput {
	return o.ApplyT(func(v ChallengeType) ChallengeSpec { return v.Spec }).(ChallengeSpecOutput)
}

func (o ChallengeTypeOutput) Status() ChallengeStatusPtrOutput {
	return o.ApplyT(func(v ChallengeType) *ChallengeStatus { return v.Status }).(ChallengeStatusPtrOutput)
}

type ChallengeMetadata struct {
}

// ChallengeMetadataInput is an input type that accepts ChallengeMetadataArgs and ChallengeMetadataOutput values.
// You can construct a concrete instance of `ChallengeMetadataInput` via:
//
//          ChallengeMetadataArgs{...}
type ChallengeMetadataInput interface {
	pulumi.Input

	ToChallengeMetadataOutput() ChallengeMetadataOutput
	ToChallengeMetadataOutputWithContext(context.Context) ChallengeMetadataOutput
}

type ChallengeMetadataArgs struct {
}

func (ChallengeMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeMetadata)(nil)).Elem()
}

func (i ChallengeMetadataArgs) ToChallengeMetadataOutput() ChallengeMetadataOutput {
	return i.ToChallengeMetadataOutputWithContext(context.Background())
}

func (i ChallengeMetadataArgs) ToChallengeMetadataOutputWithContext(ctx context.Context) ChallengeMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeMetadataOutput)
}

type ChallengeMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeMetadata)(nil)).Elem()
}

func (o ChallengeMetadataOutput) ToChallengeMetadataOutput() ChallengeMetadataOutput {
	return o
}

func (o ChallengeMetadataOutput) ToChallengeMetadataOutputWithContext(ctx context.Context) ChallengeMetadataOutput {
	return o
}

type ChallengeSpec struct {
	// The URL to the ACME Authorization resource that this challenge is a part of.
	AuthorizationURL string `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com. If the requested DNSName is a 'wildcard', this field MUST be set to the non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName string `pulumi:"dnsName"`
	// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
	IssuerRef ChallengeSpecIssuerRef `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge For HTTP01 challenges, this is the value that must be responded with to complete the HTTP01 challenge in the format: `<private key JWK thumbprint>.<key from acme server for challenge>`. For DNS01 challenges, this is the base64 encoded SHA256 sum of the `<private key JWK thumbprint>.<key from acme server for challenge>` text that must be set as the TXT record content.
	Key string `pulumi:"key"`
	// Contains the domain solving configuration that should be used to solve this challenge resource.
	Solver ChallengeSpecSolver `pulumi:"solver"`
	// The ACME challenge token for this challenge. This is the raw value returned from the ACME server.
	Token string `pulumi:"token"`
	// The type of ACME challenge this resource represents. One of "HTTP-01" or "DNS-01".
	Type string `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge. This can be used to lookup details about the status of this challenge.
	Url string `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier, for example '*.example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// ChallengeSpecInput is an input type that accepts ChallengeSpecArgs and ChallengeSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecInput` via:
//
//          ChallengeSpecArgs{...}
type ChallengeSpecInput interface {
	pulumi.Input

	ToChallengeSpecOutput() ChallengeSpecOutput
	ToChallengeSpecOutputWithContext(context.Context) ChallengeSpecOutput
}

type ChallengeSpecArgs struct {
	// The URL to the ACME Authorization resource that this challenge is a part of.
	AuthorizationURL pulumi.StringInput `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com. If the requested DNSName is a 'wildcard', this field MUST be set to the non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName pulumi.StringInput `pulumi:"dnsName"`
	// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
	IssuerRef ChallengeSpecIssuerRefInput `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge For HTTP01 challenges, this is the value that must be responded with to complete the HTTP01 challenge in the format: `<private key JWK thumbprint>.<key from acme server for challenge>`. For DNS01 challenges, this is the base64 encoded SHA256 sum of the `<private key JWK thumbprint>.<key from acme server for challenge>` text that must be set as the TXT record content.
	Key pulumi.StringInput `pulumi:"key"`
	// Contains the domain solving configuration that should be used to solve this challenge resource.
	Solver ChallengeSpecSolverInput `pulumi:"solver"`
	// The ACME challenge token for this challenge. This is the raw value returned from the ACME server.
	Token pulumi.StringInput `pulumi:"token"`
	// The type of ACME challenge this resource represents. One of "HTTP-01" or "DNS-01".
	Type pulumi.StringInput `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge. This can be used to lookup details about the status of this challenge.
	Url pulumi.StringInput `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier, for example '*.example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (ChallengeSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (i ChallengeSpecArgs) ToChallengeSpecOutput() ChallengeSpecOutput {
	return i.ToChallengeSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput)
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput).ToChallengeSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecPtrInput is an input type that accepts ChallengeSpecArgs, ChallengeSpecPtr and ChallengeSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecPtrInput` via:
//
//          ChallengeSpecArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput
	ToChallengeSpecPtrOutputWithContext(context.Context) ChallengeSpecPtrOutput
}

type challengeSpecPtrType ChallengeSpecArgs

func ChallengeSpecPtr(v *ChallengeSpecArgs) ChallengeSpecPtrInput {
	return (*challengeSpecPtrType)(v)
}

func (*challengeSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPtrOutput)
}

type ChallengeSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecOutput) ToChallengeSpecOutput() ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *ChallengeSpec {
		return &v
	}).(ChallengeSpecPtrOutput)
}

// The URL to the ACME Authorization resource that this challenge is a part of.
func (o ChallengeSpecOutput) AuthorizationURL() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.AuthorizationURL }).(pulumi.StringOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com. If the requested DNSName is a 'wildcard', this field MUST be set to the non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.DnsName }).(pulumi.StringOutput)
}

// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
func (o ChallengeSpecOutput) IssuerRef() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v ChallengeSpec) ChallengeSpecIssuerRef { return v.IssuerRef }).(ChallengeSpecIssuerRefOutput)
}

// The ACME challenge key for this challenge For HTTP01 challenges, this is the value that must be responded with to complete the HTTP01 challenge in the format: `<private key JWK thumbprint>.<key from acme server for challenge>`. For DNS01 challenges, this is the base64 encoded SHA256 sum of the `<private key JWK thumbprint>.<key from acme server for challenge>` text that must be set as the TXT record content.
func (o ChallengeSpecOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Key }).(pulumi.StringOutput)
}

// Contains the domain solving configuration that should be used to solve this challenge resource.
func (o ChallengeSpecOutput) Solver() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v ChallengeSpec) ChallengeSpecSolver { return v.Solver }).(ChallengeSpecSolverOutput)
}

// The ACME challenge token for this challenge. This is the raw value returned from the ACME server.
func (o ChallengeSpecOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Token }).(pulumi.StringOutput)
}

// The type of ACME challenge this resource represents. One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Type }).(pulumi.StringOutput)
}

// The URL of the ACME Challenge resource for this challenge. This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Url }).(pulumi.StringOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier, for example '*.example.com'.
func (o ChallengeSpecOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type ChallengeSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) Elem() ChallengeSpecOutput {
	return o.ApplyT(func(v *ChallengeSpec) ChallengeSpec { return *v }).(ChallengeSpecOutput)
}

// The URL to the ACME Authorization resource that this challenge is a part of.
func (o ChallengeSpecPtrOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.AuthorizationURL
	}).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com. If the requested DNSName is a 'wildcard', this field MUST be set to the non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecPtrOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.DnsName
	}).(pulumi.StringPtrOutput)
}

// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
func (o ChallengeSpecPtrOutput) IssuerRef() ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecIssuerRef {
		if v == nil {
			return nil
		}
		return &v.IssuerRef
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// The ACME challenge key for this challenge For HTTP01 challenges, this is the value that must be responded with to complete the HTTP01 challenge in the format: `<private key JWK thumbprint>.<key from acme server for challenge>`. For DNS01 challenges, this is the base64 encoded SHA256 sum of the `<private key JWK thumbprint>.<key from acme server for challenge>` text that must be set as the TXT record content.
func (o ChallengeSpecPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// Contains the domain solving configuration that should be used to solve this challenge resource.
func (o ChallengeSpecPtrOutput) Solver() ChallengeSpecSolverPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecSolver {
		if v == nil {
			return nil
		}
		return &v.Solver
	}).(ChallengeSpecSolverPtrOutput)
}

// The ACME challenge token for this challenge. This is the raw value returned from the ACME server.
func (o ChallengeSpecPtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Token
	}).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents. One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge. This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Url
	}).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier, for example '*.example.com'.
func (o ChallengeSpecPtrOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *bool {
		if v == nil {
			return nil
		}
		return v.Wildcard
	}).(pulumi.BoolPtrOutput)
}

// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
type ChallengeSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name string `pulumi:"name"`
}

// ChallengeSpecIssuerRefInput is an input type that accepts ChallengeSpecIssuerRefArgs and ChallengeSpecIssuerRefOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefInput` via:
//
//          ChallengeSpecIssuerRefArgs{...}
type ChallengeSpecIssuerRefInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput
	ToChallengeSpecIssuerRefOutputWithContext(context.Context) ChallengeSpecIssuerRefOutput
}

// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
type ChallengeSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return i.ToChallengeSpecIssuerRefOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput)
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput).ToChallengeSpecIssuerRefPtrOutputWithContext(ctx)
}

// ChallengeSpecIssuerRefPtrInput is an input type that accepts ChallengeSpecIssuerRefArgs, ChallengeSpecIssuerRefPtr and ChallengeSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefPtrInput` via:
//
//          ChallengeSpecIssuerRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput
	ToChallengeSpecIssuerRefPtrOutputWithContext(context.Context) ChallengeSpecIssuerRefPtrOutput
}

type challengeSpecIssuerRefPtrType ChallengeSpecIssuerRefArgs

func ChallengeSpecIssuerRefPtr(v *ChallengeSpecIssuerRefArgs) ChallengeSpecIssuerRefPtrInput {
	return (*challengeSpecIssuerRefPtrType)(v)
}

func (*challengeSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPtrOutput)
}

// References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Challenge will be marked as failed.
type ChallengeSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *ChallengeSpecIssuerRef {
		return &v
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) Elem() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) ChallengeSpecIssuerRef { return *v }).(ChallengeSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Contains the domain solving configuration that should be used to solve this challenge resource.
type ChallengeSpecSolver struct {
	// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
	Dns01 *ChallengeSpecSolverDns01 `pulumi:"dns01"`
	// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	Http01 *ChallengeSpecSolverHttp01 `pulumi:"http01"`
	// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
	Selector *ChallengeSpecSolverSelector `pulumi:"selector"`
}

// ChallengeSpecSolverInput is an input type that accepts ChallengeSpecSolverArgs and ChallengeSpecSolverOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverInput` via:
//
//          ChallengeSpecSolverArgs{...}
type ChallengeSpecSolverInput interface {
	pulumi.Input

	ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput
	ToChallengeSpecSolverOutputWithContext(context.Context) ChallengeSpecSolverOutput
}

// Contains the domain solving configuration that should be used to solve this challenge resource.
type ChallengeSpecSolverArgs struct {
	// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
	Dns01 ChallengeSpecSolverDns01PtrInput `pulumi:"dns01"`
	// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	Http01 ChallengeSpecSolverHttp01PtrInput `pulumi:"http01"`
	// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
	Selector ChallengeSpecSolverSelectorPtrInput `pulumi:"selector"`
}

func (ChallengeSpecSolverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return i.ToChallengeSpecSolverOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput)
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput).ToChallengeSpecSolverPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverPtrInput is an input type that accepts ChallengeSpecSolverArgs, ChallengeSpecSolverPtr and ChallengeSpecSolverPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverPtrInput` via:
//
//          ChallengeSpecSolverArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput
	ToChallengeSpecSolverPtrOutputWithContext(context.Context) ChallengeSpecSolverPtrOutput
}

type challengeSpecSolverPtrType ChallengeSpecSolverArgs

func ChallengeSpecSolverPtr(v *ChallengeSpecSolverArgs) ChallengeSpecSolverPtrInput {
	return (*challengeSpecSolverPtrType)(v)
}

func (*challengeSpecSolverPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPtrOutput)
}

// Contains the domain solving configuration that should be used to solve this challenge resource.
type ChallengeSpecSolverOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolver {
		return &v
	}).(ChallengeSpecSolverPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
func (o ChallengeSpecSolverOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverDns01 { return v.Dns01 }).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
func (o ChallengeSpecSolverOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverHttp01 { return v.Http01 }).(ChallengeSpecSolverHttp01PtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
func (o ChallengeSpecSolverOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverSelector { return v.Selector }).(ChallengeSpecSolverSelectorPtrOutput)
}

type ChallengeSpecSolverPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) Elem() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) ChallengeSpecSolver { return *v }).(ChallengeSpecSolverOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
func (o ChallengeSpecSolverPtrOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverDns01 {
		if v == nil {
			return nil
		}
		return v.Dns01
	}).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
func (o ChallengeSpecSolverPtrOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverHttp01 {
		if v == nil {
			return nil
		}
		return v.Http01
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
func (o ChallengeSpecSolverPtrOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01 struct {
	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
	AcmeDNS *ChallengeSpecSolverDns01AcmeDNS `pulumi:"acmeDNS"`
	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	Akamai *ChallengeSpecSolverDns01Akamai `pulumi:"akamai"`
	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	AzureDNS *ChallengeSpecSolverDns01AzureDNS `pulumi:"azureDNS"`
	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	CloudDNS *ChallengeSpecSolverDns01CloudDNS `pulumi:"cloudDNS"`
	// Use the Cloudflare API to manage DNS01 challenge records.
	Cloudflare *ChallengeSpecSolverDns01Cloudflare `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.
	CnameStrategy *string `pulumi:"cnameStrategy"`
	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	Digitalocean *ChallengeSpecSolverDns01Digitalocean `pulumi:"digitalocean"`
	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
	Rfc2136 *ChallengeSpecSolverDns01Rfc2136 `pulumi:"rfc2136"`
	// Use the AWS Route53 API to manage DNS01 challenge records.
	Route53 *ChallengeSpecSolverDns01Route53 `pulumi:"route53"`
	// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
	Webhook *ChallengeSpecSolverDns01Webhook `pulumi:"webhook"`
}

// ChallengeSpecSolverDns01Input is an input type that accepts ChallengeSpecSolverDns01Args and ChallengeSpecSolverDns01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Input` via:
//
//          ChallengeSpecSolverDns01Args{...}
type ChallengeSpecSolverDns01Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output
	ToChallengeSpecSolverDns01OutputWithContext(context.Context) ChallengeSpecSolverDns01Output
}

// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Args struct {
	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
	AcmeDNS ChallengeSpecSolverDns01AcmeDNSPtrInput `pulumi:"acmeDNS"`
	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	Akamai ChallengeSpecSolverDns01AkamaiPtrInput `pulumi:"akamai"`
	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	AzureDNS ChallengeSpecSolverDns01AzureDNSPtrInput `pulumi:"azureDNS"`
	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	CloudDNS ChallengeSpecSolverDns01CloudDNSPtrInput `pulumi:"cloudDNS"`
	// Use the Cloudflare API to manage DNS01 challenge records.
	Cloudflare ChallengeSpecSolverDns01CloudflarePtrInput `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.
	CnameStrategy pulumi.StringPtrInput `pulumi:"cnameStrategy"`
	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	Digitalocean ChallengeSpecSolverDns01DigitaloceanPtrInput `pulumi:"digitalocean"`
	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
	Rfc2136 ChallengeSpecSolverDns01Rfc2136PtrInput `pulumi:"rfc2136"`
	// Use the AWS Route53 API to manage DNS01 challenge records.
	Route53 ChallengeSpecSolverDns01Route53PtrInput `pulumi:"route53"`
	// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
	Webhook ChallengeSpecSolverDns01WebhookPtrInput `pulumi:"webhook"`
}

func (ChallengeSpecSolverDns01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return i.ToChallengeSpecSolverDns01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output)
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output).ToChallengeSpecSolverDns01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01PtrInput is an input type that accepts ChallengeSpecSolverDns01Args, ChallengeSpecSolverDns01Ptr and ChallengeSpecSolverDns01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01PtrInput` via:
//
//          ChallengeSpecSolverDns01Args{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput
	ToChallengeSpecSolverDns01PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01PtrOutput
}

type challengeSpecSolverDns01PtrType ChallengeSpecSolverDns01Args

func ChallengeSpecSolverDns01Ptr(v *ChallengeSpecSolverDns01Args) ChallengeSpecSolverDns01PtrInput {
	return (*challengeSpecSolverDns01PtrType)(v)
}

func (*challengeSpecSolverDns01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01 {
		return &v
	}).(ChallengeSpecSolverDns01PtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) AcmeDNS() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDNS { return v.AcmeDNS }).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai { return v.Akamai }).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) AzureDNS() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDNS { return v.AzureDNS }).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) CloudDNS() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDNS { return v.CloudDNS }).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare { return v.Cloudflare }).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.
func (o ChallengeSpecSolverDns01Output) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *string { return v.CnameStrategy }).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean { return v.Digitalocean }).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 { return v.Rfc2136 }).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 { return v.Route53 }).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook { return v.Webhook }).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

type ChallengeSpecSolverDns01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) Elem() ChallengeSpecSolverDns01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) ChallengeSpecSolverDns01 { return *v }).(ChallengeSpecSolverDns01Output)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) AcmeDNS() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDNS {
		if v == nil {
			return nil
		}
		return v.AcmeDNS
	}).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) AzureDNS() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDNS {
		if v == nil {
			return nil
		}
		return v.AzureDNS
	}).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) CloudDNS() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDNS {
		if v == nil {
			return nil
		}
		return v.CloudDNS
	}).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare {
		if v == nil {
			return nil
		}
		return v.Cloudflare
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.
func (o ChallengeSpecSolverDns01PtrOutput) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *string {
		if v == nil {
			return nil
		}
		return v.CnameStrategy
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean {
		if v == nil {
			return nil
		}
		return v.Digitalocean
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 {
		if v == nil {
			return nil
		}
		return v.Rfc2136
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 {
		if v == nil {
			return nil
		}
		return v.Route53
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook {
		if v == nil {
			return nil
		}
		return v.Webhook
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNS struct {
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	AccountSecretRef ChallengeSpecSolverDns01AcmeDNSAccountSecretRef `pulumi:"accountSecretRef"`
	Host             string                                          `pulumi:"host"`
}

// ChallengeSpecSolverDns01AcmeDNSInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSArgs and ChallengeSpecSolverDns01AcmeDNSOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSInput` via:
//
//          ChallengeSpecSolverDns01AcmeDNSArgs{...}
type ChallengeSpecSolverDns01AcmeDNSInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSOutput() ChallengeSpecSolverDns01AcmeDNSOutput
	ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSOutput
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSArgs struct {
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	AccountSecretRef ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput `pulumi:"accountSecretRef"`
	Host             pulumi.StringInput                                   `pulumi:"host"`
}

func (ChallengeSpecSolverDns01AcmeDNSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSOutput() ChallengeSpecSolverDns01AcmeDNSOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSOutput)
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSArgs) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSOutput).ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDNSPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSArgs, ChallengeSpecSolverDns01AcmeDNSPtr and ChallengeSpecSolverDns01AcmeDNSPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSPtrInput` via:
//
//          ChallengeSpecSolverDns01AcmeDNSArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AcmeDNSPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput
	ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput
}

type challengeSpecSolverDns01AcmeDNSPtrType ChallengeSpecSolverDns01AcmeDNSArgs

func ChallengeSpecSolverDns01AcmeDNSPtr(v *ChallengeSpecSolverDns01AcmeDNSArgs) ChallengeSpecSolverDns01AcmeDNSPtrInput {
	return (*challengeSpecSolverDns01AcmeDNSPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDNSPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDNSPtrType) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDNSPtrType) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDNSOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSOutput() ChallengeSpecSolverDns01AcmeDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNS) *ChallengeSpecSolverDns01AcmeDNS {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDNSPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AcmeDNSOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNS) ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNS) string { return v.Host }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AcmeDNSPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutput() ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) ToChallengeSpecSolverDns01AcmeDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDNSOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNS) ChallengeSpecSolverDns01AcmeDNS { return *v }).(ChallengeSpecSolverDns01AcmeDNSOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNS) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		if v == nil {
			return nil
		}
		return &v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDNSPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNS) *string {
		if v == nil {
			return nil
		}
		return &v.Host
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs and ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput` via:
//
//          ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput
	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput).ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs, ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtr and ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs

func ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtr(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRefArgs) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDNSAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDNSAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) ChallengeSpecSolverDns01AcmeDNSAccountSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDNSAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Akamai struct {
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	AccessTokenSecretRef ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef `pulumi:"accessTokenSecretRef"`
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRef `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain string                                             `pulumi:"serviceConsumerDomain"`
}

// ChallengeSpecSolverDns01AkamaiInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs and ChallengeSpecSolverDns01AkamaiOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiInput` via:
//
//          ChallengeSpecSolverDns01AkamaiArgs{...}
type ChallengeSpecSolverDns01AkamaiInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput
	ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiOutput
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiArgs struct {
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	AccessTokenSecretRef ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput `pulumi:"accessTokenSecretRef"`
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput `pulumi:"clientSecretSecretRef"`
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain pulumi.StringInput                                      `pulumi:"serviceConsumerDomain"`
}

func (ChallengeSpecSolverDns01AkamaiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return i.ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput)
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput).ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs, ChallengeSpecSolverDns01AkamaiPtr and ChallengeSpecSolverDns01AkamaiPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiPtrInput` via:
//
//          ChallengeSpecSolverDns01AkamaiArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AkamaiPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput
	ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput
}

type challengeSpecSolverDns01AkamaiPtrType ChallengeSpecSolverDns01AkamaiArgs

func ChallengeSpecSolverDns01AkamaiPtr(v *ChallengeSpecSolverDns01AkamaiArgs) ChallengeSpecSolverDns01AkamaiPtrInput {
	return (*challengeSpecSolverDns01AkamaiPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01Akamai {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ServiceConsumerDomain() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) string { return v.ServiceConsumerDomain }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01Akamai { return *v }).(ChallengeSpecSolverDns01AkamaiOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return &v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceConsumerDomain
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput` via:
//
//          ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput` via:
//
//          ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput` via:
//
//          ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNS struct {
	// if both this and ClientSecret are left unset MSI will be used
	ClientID *string `pulumi:"clientID"`
	// if both this and ClientID are left unset MSI will be used
	ClientSecretSecretRef *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	Environment           *string                                                `pulumi:"environment"`
	HostedZoneName        *string                                                `pulumi:"hostedZoneName"`
	ResourceGroupName     string                                                 `pulumi:"resourceGroupName"`
	SubscriptionID        string                                                 `pulumi:"subscriptionID"`
	// when specifying ClientID and ClientSecret then this field is also needed
	TenantID *string `pulumi:"tenantID"`
}

// ChallengeSpecSolverDns01AzureDNSInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSArgs and ChallengeSpecSolverDns01AzureDNSOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSInput` via:
//
//          ChallengeSpecSolverDns01AzureDNSArgs{...}
type ChallengeSpecSolverDns01AzureDNSInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSOutput() ChallengeSpecSolverDns01AzureDNSOutput
	ToChallengeSpecSolverDns01AzureDNSOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSOutput
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSArgs struct {
	// if both this and ClientSecret are left unset MSI will be used
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// if both this and ClientID are left unset MSI will be used
	ClientSecretSecretRef ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput `pulumi:"clientSecretSecretRef"`
	Environment           pulumi.StringPtrInput                                         `pulumi:"environment"`
	HostedZoneName        pulumi.StringPtrInput                                         `pulumi:"hostedZoneName"`
	ResourceGroupName     pulumi.StringInput                                            `pulumi:"resourceGroupName"`
	SubscriptionID        pulumi.StringInput                                            `pulumi:"subscriptionID"`
	// when specifying ClientID and ClientSecret then this field is also needed
	TenantID pulumi.StringPtrInput `pulumi:"tenantID"`
}

func (ChallengeSpecSolverDns01AzureDNSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSOutput() ChallengeSpecSolverDns01AzureDNSOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSArgs) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSOutput).ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSArgs, ChallengeSpecSolverDns01AzureDNSPtr and ChallengeSpecSolverDns01AzureDNSPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSPtrInput` via:
//
//          ChallengeSpecSolverDns01AzureDNSArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AzureDNSPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput
	ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput
}

type challengeSpecSolverDns01AzureDNSPtrType ChallengeSpecSolverDns01AzureDNSArgs

func ChallengeSpecSolverDns01AzureDNSPtr(v *ChallengeSpecSolverDns01AzureDNSArgs) ChallengeSpecSolverDns01AzureDNSPtrInput {
	return (*challengeSpecSolverDns01AzureDNSPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSPtrType) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSPtrType) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDNSOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSOutput() ChallengeSpecSolverDns01AzureDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNS {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSPtrOutput)
}

// if both this and ClientSecret are left unset MSI will be used
func (o ChallengeSpecSolverDns01AzureDNSOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// if both this and ClientID are left unset MSI will be used
func (o ChallengeSpecSolverDns01AzureDNSOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.Environment }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) string { return v.ResourceGroupName }).(pulumi.StringOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSOutput) SubscriptionID() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) string { return v.SubscriptionID }).(pulumi.StringOutput)
}

// when specifying ClientID and ClientSecret then this field is also needed
func (o ChallengeSpecSolverDns01AzureDNSOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNS) *string { return v.TenantID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDNSPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutput() ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ToChallengeSpecSolverDns01AzureDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) ChallengeSpecSolverDns01AzureDNS { return *v }).(ChallengeSpecSolverDns01AzureDNSOutput)
}

// if both this and ClientSecret are left unset MSI will be used
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// if both this and ClientID are left unset MSI will be used
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.Environment
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceGroupName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return &v.SubscriptionID
	}).(pulumi.StringPtrOutput)
}

// when specifying ClientID and ClientSecret then this field is also needed
func (o ChallengeSpecSolverDns01AzureDNSPtrOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNS) *string {
		if v == nil {
			return nil
		}
		return v.TenantID
	}).(pulumi.StringPtrOutput)
}

// if both this and ClientID are left unset MSI will be used
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs and ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput` via:
//
//          ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput
}

// if both this and ClientID are left unset MSI will be used
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs, ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtr and ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefArgs) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

// if both this and ClientID are left unset MSI will be used
type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDNSClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNS struct {
	// HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone.
	HostedZoneName *string `pulumi:"hostedZoneName"`
	Project        string  `pulumi:"project"`
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	ServiceAccountSecretRef *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef `pulumi:"serviceAccountSecretRef"`
}

// ChallengeSpecSolverDns01CloudDNSInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSArgs and ChallengeSpecSolverDns01CloudDNSOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSInput` via:
//
//          ChallengeSpecSolverDns01CloudDNSArgs{...}
type ChallengeSpecSolverDns01CloudDNSInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSOutput() ChallengeSpecSolverDns01CloudDNSOutput
	ToChallengeSpecSolverDns01CloudDNSOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSOutput
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSArgs struct {
	// HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone.
	HostedZoneName pulumi.StringPtrInput `pulumi:"hostedZoneName"`
	Project        pulumi.StringInput    `pulumi:"project"`
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	ServiceAccountSecretRef ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput `pulumi:"serviceAccountSecretRef"`
}

func (ChallengeSpecSolverDns01CloudDNSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSOutput() ChallengeSpecSolverDns01CloudDNSOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSOutput)
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSArgs) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSOutput).ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDNSPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSArgs, ChallengeSpecSolverDns01CloudDNSPtr and ChallengeSpecSolverDns01CloudDNSPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSPtrInput` via:
//
//          ChallengeSpecSolverDns01CloudDNSArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01CloudDNSPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput
	ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput
}

type challengeSpecSolverDns01CloudDNSPtrType ChallengeSpecSolverDns01CloudDNSArgs

func ChallengeSpecSolverDns01CloudDNSPtr(v *ChallengeSpecSolverDns01CloudDNSArgs) ChallengeSpecSolverDns01CloudDNSPtrInput {
	return (*challengeSpecSolverDns01CloudDNSPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDNSPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDNSPtrType) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDNSPtrType) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDNSOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSOutput() ChallengeSpecSolverDns01CloudDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) *ChallengeSpecSolverDns01CloudDNS {
		return &v
	}).(ChallengeSpecSolverDns01CloudDNSPtrOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDNSOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) string { return v.Project }).(pulumi.StringOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01CloudDNSOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNS) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01CloudDNSPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNS)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutput() ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) ToChallengeSpecSolverDns01CloudDNSPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) Elem() ChallengeSpecSolverDns01CloudDNSOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) ChallengeSpecSolverDns01CloudDNS { return *v }).(ChallengeSpecSolverDns01CloudDNSOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) *string {
		if v == nil {
			return nil
		}
		return &v.Project
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01CloudDNSPtrOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNS) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		if v == nil {
			return nil
		}
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs and ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput` via:
//
//          ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput
	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput).ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs, ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtr and ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs

func ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtr(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefArgs) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Cloudflare struct {
	// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
	ApiKeySecretRef *ChallengeSpecSolverDns01CloudflareApiKeySecretRef `pulumi:"apiKeySecretRef"`
	// API token used to authenticate with Cloudflare.
	ApiTokenSecretRef *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email *string `pulumi:"email"`
}

// ChallengeSpecSolverDns01CloudflareInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs and ChallengeSpecSolverDns01CloudflareOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareInput` via:
//
//          ChallengeSpecSolverDns01CloudflareArgs{...}
type ChallengeSpecSolverDns01CloudflareInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput
	ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareOutput
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareArgs struct {
	// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
	ApiKeySecretRef ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput `pulumi:"apiKeySecretRef"`
	// API token used to authenticate with Cloudflare.
	ApiTokenSecretRef ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email pulumi.StringPtrInput `pulumi:"email"`
}

func (ChallengeSpecSolverDns01CloudflareArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return i.ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput)
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput).ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflarePtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs, ChallengeSpecSolverDns01CloudflarePtr and ChallengeSpecSolverDns01CloudflarePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflarePtrInput` via:
//
//          ChallengeSpecSolverDns01CloudflareArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01CloudflarePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput
	ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput
}

type challengeSpecSolverDns01CloudflarePtrType ChallengeSpecSolverDns01CloudflareArgs

func ChallengeSpecSolverDns01CloudflarePtr(v *ChallengeSpecSolverDns01CloudflareArgs) ChallengeSpecSolverDns01CloudflarePtrInput {
	return (*challengeSpecSolverDns01CloudflarePtrType)(v)
}

func (*challengeSpecSolverDns01CloudflarePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01Cloudflare {
		return &v
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
func (o ChallengeSpecSolverDns01CloudflareOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
func (o ChallengeSpecSolverDns01CloudflareOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflareOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *string { return v.Email }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflarePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflarePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Elem() ChallengeSpecSolverDns01CloudflareOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) ChallengeSpecSolverDns01Cloudflare { return *v }).(ChallengeSpecSolverDns01CloudflareOutput)
}

// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v == nil {
			return nil
		}
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *string {
		if v == nil {
			return nil
		}
		return v.Email
	}).(pulumi.StringPtrOutput)
}

// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs and ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput` via:
//
//          ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
}

// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs, ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr and ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return *v
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput` via:
//
//          ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs, ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Digitalocean struct {
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRef `pulumi:"tokenSecretRef"`
}

// ChallengeSpecSolverDns01DigitaloceanInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs and ChallengeSpecSolverDns01DigitaloceanOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanInput` via:
//
//          ChallengeSpecSolverDns01DigitaloceanArgs{...}
type ChallengeSpecSolverDns01DigitaloceanInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput
	ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanOutput
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanArgs struct {
	// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput `pulumi:"tokenSecretRef"`
}

func (ChallengeSpecSolverDns01DigitaloceanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput).ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs, ChallengeSpecSolverDns01DigitaloceanPtr and ChallengeSpecSolverDns01DigitaloceanPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanPtrInput` via:
//
//          ChallengeSpecSolverDns01DigitaloceanArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01DigitaloceanPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput
}

type challengeSpecSolverDns01DigitaloceanPtrType ChallengeSpecSolverDns01DigitaloceanArgs

func ChallengeSpecSolverDns01DigitaloceanPtr(v *ChallengeSpecSolverDns01DigitaloceanArgs) ChallengeSpecSolverDns01DigitaloceanPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01Digitalocean {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01DigitaloceanOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

type ChallengeSpecSolverDns01DigitaloceanPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01Digitalocean { return *v }).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput` via:
//
//          ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput).ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs, ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs

func ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136 struct {
	// The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]); port is optional. This field is required.
	Nameserver string `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined. Supported values are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm *string `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS. If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName *string `pulumi:"tsigKeyName"`
	// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
	TsigSecretSecretRef *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef `pulumi:"tsigSecretSecretRef"`
}

// ChallengeSpecSolverDns01Rfc2136Input is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args and ChallengeSpecSolverDns01Rfc2136Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136Input` via:
//
//          ChallengeSpecSolverDns01Rfc2136Args{...}
type ChallengeSpecSolverDns01Rfc2136Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output
	ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136Output
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Args struct {
	// The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]); port is optional. This field is required.
	Nameserver pulumi.StringInput `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined. Supported values are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm pulumi.StringPtrInput `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS. If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName pulumi.StringPtrInput `pulumi:"tsigKeyName"`
	// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
	TsigSecretSecretRef ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput `pulumi:"tsigSecretSecretRef"`
}

func (ChallengeSpecSolverDns01Rfc2136Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return i.ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output)
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output).ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136PtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args, ChallengeSpecSolverDns01Rfc2136Ptr and ChallengeSpecSolverDns01Rfc2136PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136PtrInput` via:
//
//          ChallengeSpecSolverDns01Rfc2136Args{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01Rfc2136PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput
	ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput
}

type challengeSpecSolverDns01Rfc2136PtrType ChallengeSpecSolverDns01Rfc2136Args

func ChallengeSpecSolverDns01Rfc2136Ptr(v *ChallengeSpecSolverDns01Rfc2136Args) ChallengeSpecSolverDns01Rfc2136PtrInput {
	return (*challengeSpecSolverDns01Rfc2136PtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136 {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]); port is optional. This field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) Nameserver() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) string { return v.Nameserver }).(pulumi.StringOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined. Supported values are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigAlgorithm }).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS. If ``tsigSecretSecretRef`` is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigKeyName }).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) ChallengeSpecSolverDns01Rfc2136 { return *v }).(ChallengeSpecSolverDns01Rfc2136Output)
}

// The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]); port is optional. This field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return &v.Nameserver
	}).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined. Supported values are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigAlgorithm
	}).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS. If ``tsigSecretSecretRef`` is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigKeyName
	}).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput` via:
//
//          ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
}

// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput).ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs, ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs

func ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return *v
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53 struct {
	// The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID *string `pulumi:"accessKeyID"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID *string `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region string `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role *string `pulumi:"role"`
	// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	SecretAccessKeySecretRef *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef `pulumi:"secretAccessKeySecretRef"`
}

// ChallengeSpecSolverDns01Route53Input is an input type that accepts ChallengeSpecSolverDns01Route53Args and ChallengeSpecSolverDns01Route53Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53Input` via:
//
//          ChallengeSpecSolverDns01Route53Args{...}
type ChallengeSpecSolverDns01Route53Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output
	ToChallengeSpecSolverDns01Route53OutputWithContext(context.Context) ChallengeSpecSolverDns01Route53Output
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Args struct {
	// The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID pulumi.StringPtrInput `pulumi:"accessKeyID"`
	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID pulumi.StringPtrInput `pulumi:"hostedZoneID"`
	// Always set the region when using AccessKeyID and SecretAccessKey
	Region pulumi.StringInput `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role pulumi.StringPtrInput `pulumi:"role"`
	// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	SecretAccessKeySecretRef ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput `pulumi:"secretAccessKeySecretRef"`
}

func (ChallengeSpecSolverDns01Route53Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return i.ToChallengeSpecSolverDns01Route53OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output)
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output).ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53PtrInput is an input type that accepts ChallengeSpecSolverDns01Route53Args, ChallengeSpecSolverDns01Route53Ptr and ChallengeSpecSolverDns01Route53PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53PtrInput` via:
//
//          ChallengeSpecSolverDns01Route53Args{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01Route53PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput
	ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53PtrOutput
}

type challengeSpecSolverDns01Route53PtrType ChallengeSpecSolverDns01Route53Args

func ChallengeSpecSolverDns01Route53Ptr(v *ChallengeSpecSolverDns01Route53Args) ChallengeSpecSolverDns01Route53PtrInput {
	return (*challengeSpecSolverDns01Route53PtrType)(v)
}

func (*challengeSpecSolverDns01Route53PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53 {
		return &v
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.AccessKeyID }).(pulumi.StringPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53Output) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.HostedZoneID }).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53Output) Region() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) string { return v.Region }).(pulumi.StringOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53Output) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.Role }).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Route53PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) Elem() ChallengeSpecSolverDns01Route53Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) ChallengeSpecSolverDns01Route53 { return *v }).(ChallengeSpecSolverDns01Route53Output)
}

// The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.AccessKeyID
	}).(pulumi.StringPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53PtrOutput) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneID
	}).(pulumi.StringPtrOutput)
}

// Always set the region when using AccessKeyID and SecretAccessKey
func (o ChallengeSpecSolverDns01Route53PtrOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return &v.Region
	}).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53PtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v == nil {
			return nil
		}
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput` via:
//
//          ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
}

// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput).ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs, ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput` via:
//
//          ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
}

type challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs

func ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return *v
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Webhook struct {
	// Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation's documentation.
	Config map[string]interface{} `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation.
	GroupName string `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName string `pulumi:"solverName"`
}

// ChallengeSpecSolverDns01WebhookInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs and ChallengeSpecSolverDns01WebhookOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookInput` via:
//
//          ChallengeSpecSolverDns01WebhookArgs{...}
type ChallengeSpecSolverDns01WebhookInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput
	ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookOutput
}

// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookArgs struct {
	// Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation's documentation.
	Config pulumi.MapInput `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation.
	GroupName pulumi.StringInput `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName pulumi.StringInput `pulumi:"solverName"`
}

func (ChallengeSpecSolverDns01WebhookArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return i.ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput)
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput).ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01WebhookPtrInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs, ChallengeSpecSolverDns01WebhookPtr and ChallengeSpecSolverDns01WebhookPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookPtrInput` via:
//
//          ChallengeSpecSolverDns01WebhookArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverDns01WebhookPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput
	ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookPtrOutput
}

type challengeSpecSolverDns01WebhookPtrType ChallengeSpecSolverDns01WebhookArgs

func ChallengeSpecSolverDns01WebhookPtr(v *ChallengeSpecSolverDns01WebhookArgs) ChallengeSpecSolverDns01WebhookPtrInput {
	return (*challengeSpecSolverDns01WebhookPtrType)(v)
}

func (*challengeSpecSolverDns01WebhookPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) *ChallengeSpecSolverDns01Webhook {
		return &v
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation.
func (o ChallengeSpecSolverDns01WebhookOutput) GroupName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) string { return v.GroupName }).(pulumi.StringOutput)
}

// The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookOutput) SolverName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) string { return v.SolverName }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01WebhookPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) Elem() ChallengeSpecSolverDns01WebhookOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) ChallengeSpecSolverDns01Webhook { return *v }).(ChallengeSpecSolverDns01WebhookOutput)
}

// Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return &v.GroupName
	}).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return &v.SolverName
	}).(pulumi.StringPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01 struct {
	// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
	Ingress *ChallengeSpecSolverHttp01Ingress `pulumi:"ingress"`
}

// ChallengeSpecSolverHttp01Input is an input type that accepts ChallengeSpecSolverHttp01Args and ChallengeSpecSolverHttp01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01Input` via:
//
//          ChallengeSpecSolverHttp01Args{...}
type ChallengeSpecSolverHttp01Input interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output
	ToChallengeSpecSolverHttp01OutputWithContext(context.Context) ChallengeSpecSolverHttp01Output
}

// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Args struct {
	// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
	Ingress ChallengeSpecSolverHttp01IngressPtrInput `pulumi:"ingress"`
}

func (ChallengeSpecSolverHttp01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return i.ToChallengeSpecSolverHttp01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output)
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output).ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01PtrInput is an input type that accepts ChallengeSpecSolverHttp01Args, ChallengeSpecSolverHttp01Ptr and ChallengeSpecSolverHttp01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01PtrInput` via:
//
//          ChallengeSpecSolverHttp01Args{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput
	ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01PtrOutput
}

type challengeSpecSolverHttp01PtrType ChallengeSpecSolverHttp01Args

func ChallengeSpecSolverHttp01Ptr(v *ChallengeSpecSolverHttp01Args) ChallengeSpecSolverHttp01PtrInput {
	return (*challengeSpecSolverHttp01PtrType)(v)
}

func (*challengeSpecSolverHttp01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01 {
		return &v
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
func (o ChallengeSpecSolverHttp01Output) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress { return v.Ingress }).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

type ChallengeSpecSolverHttp01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) Elem() ChallengeSpecSolverHttp01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) ChallengeSpecSolverHttp01 { return *v }).(ChallengeSpecSolverHttp01Output)
}

// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
func (o ChallengeSpecSolverHttp01PtrOutput) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress {
		if v == nil {
			return nil
		}
		return v.Ingress
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01Ingress struct {
	// The ingress class to use when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of 'class' or 'name' may be specified.
	Class *string `pulumi:"class"`
	// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
	IngressTemplate *ChallengeSpecSolverHttp01IngressIngressTemplate `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources.
	Name *string `pulumi:"name"`
	// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
	PodTemplate *ChallengeSpecSolverHttp01IngressPodTemplate `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01IngressInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs and ChallengeSpecSolverHttp01IngressOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressInput` via:
//
//          ChallengeSpecSolverHttp01IngressArgs{...}
type ChallengeSpecSolverHttp01IngressInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput
	ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressOutput
}

// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressArgs struct {
	// The ingress class to use when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of 'class' or 'name' may be specified.
	Class pulumi.StringPtrInput `pulumi:"class"`
	// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
	IngressTemplate ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
	PodTemplate ChallengeSpecSolverHttp01IngressPodTemplatePtrInput `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01IngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return i.ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput)
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput).ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs, ChallengeSpecSolverHttp01IngressPtr and ChallengeSpecSolverHttp01IngressPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput
	ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPtrOutput
}

type challengeSpecSolverHttp01IngressPtrType ChallengeSpecSolverHttp01IngressArgs

func ChallengeSpecSolverHttp01IngressPtr(v *ChallengeSpecSolverHttp01IngressArgs) ChallengeSpecSolverHttp01IngressPtrInput {
	return (*challengeSpecSolverHttp01IngressPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01Ingress {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The ingress class to use when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of 'class' or 'name' may be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Class }).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
func (o ChallengeSpecSolverHttp01IngressOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources.
func (o ChallengeSpecSolverHttp01IngressOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
func (o ChallengeSpecSolverHttp01IngressOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service
func (o ChallengeSpecSolverHttp01IngressOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) Elem() ChallengeSpecSolverHttp01IngressOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) ChallengeSpecSolverHttp01Ingress { return *v }).(ChallengeSpecSolverHttp01IngressOutput)
}

// The ingress class to use when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of 'class' or 'name' may be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Class
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v == nil {
			return nil
		}
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
func (o ChallengeSpecSolverHttp01IngressPtrOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service
func (o ChallengeSpecSolverHttp01IngressPtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
type ChallengeSpecSolverHttp01IngressIngressTemplate struct {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata `pulumi:"metadata"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs and ChallengeSpecSolverHttp01IngressIngressTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateInput` via:
//
//          ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput
}

// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
type ChallengeSpecSolverHttp01IngressIngressTemplateArgs struct {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
	Metadata ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput `pulumi:"metadata"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput).ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs, ChallengeSpecSolverHttp01IngressIngressTemplatePtr and ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplatePtrType ChallengeSpecSolverHttp01IngressIngressTemplateArgs

func ChallengeSpecSolverHttp01IngressIngressTemplatePtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges
type ChallengeSpecSolverHttp01IngressIngressTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) ChallengeSpecSolverHttp01IngressIngressTemplate {
		return *v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadata struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput` via:
//
//          ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return *v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotations struct {
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsInput` via:
//
//          ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput {
	return o
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabels struct {
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsInput` via:
//
//          ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput {
	return o
}

// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
type ChallengeSpecSolverHttp01IngressPodTemplate struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01IngressPodTemplateMetadata `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
	Spec *ChallengeSpecSolverHttp01IngressPodTemplateSpec `pulumi:"spec"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs and ChallengeSpecSolverHttp01IngressPodTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput
}

// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
type ChallengeSpecSolverHttp01IngressPodTemplateArgs struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
	Metadata ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
	Spec ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput `pulumi:"spec"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput).ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs, ChallengeSpecSolverHttp01IngressPodTemplatePtr and ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplatePtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplatePtrType ChallengeSpecSolverHttp01IngressPodTemplateArgs

func ChallengeSpecSolverHttp01IngressPodTemplatePtr(v *ChallengeSpecSolverHttp01IngressPodTemplateArgs) ChallengeSpecSolverHttp01IngressPodTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges
type ChallengeSpecSolverHttp01IngressPodTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) ChallengeSpecSolverHttp01IngressPodTemplate {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadata struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs struct {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotations struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput)
}

// Annotations that should be added to the create ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput {
	return o
}

// Labels that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabels struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput
}

// Labels that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput {
	return o
}

// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpec struct {
	// If specified, the pod's scheduling constraints
	Affinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity `pulumi:"affinity"`
	// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName *string `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations `pulumi:"tolerations"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
}

// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs struct {
	// If specified, the pod's scheduling constraints
	Affinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput `pulumi:"affinity"`
	// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector pulumi.StringMapInput `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName pulumi.StringPtrInput `pulumi:"priorityClassName"`
	// If specified, the pod's service account
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput `pulumi:"tolerations"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod. Only the 'priorityClassName', 'nodeSelector', 'affinity', 'serviceAccountName' and 'tolerations' fields are supported currently. All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string { return v.NodeSelector }).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.PriorityClassName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.PriorityClassName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		if v == nil {
			return nil
		}
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity `pulumi:"podAntiAffinity"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput `pulumi:"podAntiAffinity"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A node selector term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Preference() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return v.Preference
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms `pulumi:"nodeSelectorTerms"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput `pulumi:"nodeSelectorTerms"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
}

// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return *v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
type ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelector struct {
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput
}

// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
type ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorArgs struct {
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
type ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput {
	return o
}

// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
}

// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput` via:
//
//          ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *int { return v.TolerationSeconds }).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
type ChallengeSpecSolverSelector struct {
	// List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
	DnsNames []string `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
	DnsZones []string `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverSelectorInput is an input type that accepts ChallengeSpecSolverSelectorArgs and ChallengeSpecSolverSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorInput` via:
//
//          ChallengeSpecSolverSelectorArgs{...}
type ChallengeSpecSolverSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput
	ToChallengeSpecSolverSelectorOutputWithContext(context.Context) ChallengeSpecSolverSelectorOutput
}

// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
type ChallengeSpecSolverSelectorArgs struct {
	// List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
	DnsZones pulumi.StringArrayInput `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return i.ToChallengeSpecSolverSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput)
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput).ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverSelectorPtrInput is an input type that accepts ChallengeSpecSolverSelectorArgs, ChallengeSpecSolverSelectorPtr and ChallengeSpecSolverSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorPtrInput` via:
//
//          ChallengeSpecSolverSelectorArgs{...}
//
//  or:
//
//          nil
type ChallengeSpecSolverSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput
	ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverSelectorPtrOutput
}

type challengeSpecSolverSelectorPtrType ChallengeSpecSolverSelectorArgs

func ChallengeSpecSolverSelectorPtr(v *ChallengeSpecSolverSelectorArgs) ChallengeSpecSolverSelectorPtrInput {
	return (*challengeSpecSolverSelectorPtrType)(v)
}

func (*challengeSpecSolverSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.
type ChallengeSpecSolverSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) *ChallengeSpecSolverSelector {
		return &v
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsZones }).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) Elem() ChallengeSpecSolverSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) ChallengeSpecSolverSelector { return *v }).(ChallengeSpecSolverSelectorOutput)
}

// List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsZones
	}).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
type ChallengeSpecSolverSelectorMatchLabels struct {
}

// ChallengeSpecSolverSelectorMatchLabelsInput is an input type that accepts ChallengeSpecSolverSelectorMatchLabelsArgs and ChallengeSpecSolverSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorMatchLabelsInput` via:
//
//          ChallengeSpecSolverSelectorMatchLabelsArgs{...}
type ChallengeSpecSolverSelectorMatchLabelsInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorMatchLabelsOutput() ChallengeSpecSolverSelectorMatchLabelsOutput
	ToChallengeSpecSolverSelectorMatchLabelsOutputWithContext(context.Context) ChallengeSpecSolverSelectorMatchLabelsOutput
}

// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
type ChallengeSpecSolverSelectorMatchLabelsArgs struct {
}

func (ChallengeSpecSolverSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelectorMatchLabels)(nil)).Elem()
}

func (i ChallengeSpecSolverSelectorMatchLabelsArgs) ToChallengeSpecSolverSelectorMatchLabelsOutput() ChallengeSpecSolverSelectorMatchLabelsOutput {
	return i.ToChallengeSpecSolverSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorMatchLabelsArgs) ToChallengeSpecSolverSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorMatchLabelsOutput)
}

// A label selector that is used to refine the set of certificate's that this challenge solver will apply to.
type ChallengeSpecSolverSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelectorMatchLabels)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorMatchLabelsOutput) ToChallengeSpecSolverSelectorMatchLabelsOutput() ChallengeSpecSolverSelectorMatchLabelsOutput {
	return o
}

func (o ChallengeSpecSolverSelectorMatchLabelsOutput) ToChallengeSpecSolverSelectorMatchLabelsOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorMatchLabelsOutput {
	return o
}

type ChallengeStatus struct {
	// presented will be set to true if the challenge values for this challenge are currently 'presented'. This *does not* imply the self check is passing. Only that the values have been 'submitted' for the appropriate challenge mechanism (i.e. the DNS01 TXT record has been presented, or the HTTP01 configuration has been configured).
	Presented *bool `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not. This field will only be set to true by the 'scheduling' component. It will only be set to false by the 'challenges' controller, after the challenge has reached a final state or timed out. If this field is set to false, the challenge controller will not take any more action.
	Processing *bool `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the current state.
	Reason *string `pulumi:"reason"`
	// Contains the current 'state' of the challenge. If not set, the state of the challenge is unknown.
	State *string `pulumi:"state"`
}

// ChallengeStatusInput is an input type that accepts ChallengeStatusArgs and ChallengeStatusOutput values.
// You can construct a concrete instance of `ChallengeStatusInput` via:
//
//          ChallengeStatusArgs{...}
type ChallengeStatusInput interface {
	pulumi.Input

	ToChallengeStatusOutput() ChallengeStatusOutput
	ToChallengeStatusOutputWithContext(context.Context) ChallengeStatusOutput
}

type ChallengeStatusArgs struct {
	// presented will be set to true if the challenge values for this challenge are currently 'presented'. This *does not* imply the self check is passing. Only that the values have been 'submitted' for the appropriate challenge mechanism (i.e. the DNS01 TXT record has been presented, or the HTTP01 configuration has been configured).
	Presented pulumi.BoolPtrInput `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not. This field will only be set to true by the 'scheduling' component. It will only be set to false by the 'challenges' controller, after the challenge has reached a final state or timed out. If this field is set to false, the challenge controller will not take any more action.
	Processing pulumi.BoolPtrInput `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Contains the current 'state' of the challenge. If not set, the state of the challenge is unknown.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (ChallengeStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (i ChallengeStatusArgs) ToChallengeStatusOutput() ChallengeStatusOutput {
	return i.ToChallengeStatusOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput)
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput).ToChallengeStatusPtrOutputWithContext(ctx)
}

// ChallengeStatusPtrInput is an input type that accepts ChallengeStatusArgs, ChallengeStatusPtr and ChallengeStatusPtrOutput values.
// You can construct a concrete instance of `ChallengeStatusPtrInput` via:
//
//          ChallengeStatusArgs{...}
//
//  or:
//
//          nil
type ChallengeStatusPtrInput interface {
	pulumi.Input

	ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput
	ToChallengeStatusPtrOutputWithContext(context.Context) ChallengeStatusPtrOutput
}

type challengeStatusPtrType ChallengeStatusArgs

func ChallengeStatusPtr(v *ChallengeStatusArgs) ChallengeStatusPtrInput {
	return (*challengeStatusPtrType)(v)
}

func (*challengeStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPtrOutput)
}

type ChallengeStatusOutput struct{ *pulumi.OutputState }

func (ChallengeStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusOutput) ToChallengeStatusOutput() ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *ChallengeStatus {
		return &v
	}).(ChallengeStatusPtrOutput)
}

// presented will be set to true if the challenge values for this challenge are currently 'presented'. This *does not* imply the self check is passing. Only that the values have been 'submitted' for the appropriate challenge mechanism (i.e. the DNS01 TXT record has been presented, or the HTTP01 configuration has been configured).
func (o ChallengeStatusOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Presented }).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not. This field will only be set to true by the 'scheduling' component. It will only be set to false by the 'challenges' controller, after the challenge has reached a final state or timed out. If this field is set to false, the challenge controller will not take any more action.
func (o ChallengeStatusOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Processing }).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the current state.
func (o ChallengeStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge. If not set, the state of the challenge is unknown.
func (o ChallengeStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

type ChallengeStatusPtrOutput struct{ *pulumi.OutputState }

func (ChallengeStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) Elem() ChallengeStatusOutput {
	return o.ApplyT(func(v *ChallengeStatus) ChallengeStatus { return *v }).(ChallengeStatusOutput)
}

// presented will be set to true if the challenge values for this challenge are currently 'presented'. This *does not* imply the self check is passing. Only that the values have been 'submitted' for the appropriate challenge mechanism (i.e. the DNS01 TXT record has been presented, or the HTTP01 configuration has been configured).
func (o ChallengeStatusPtrOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Presented
	}).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not. This field will only be set to true by the 'scheduling' component. It will only be set to false by the 'challenges' controller, after the challenge has reached a final state or timed out. If this field is set to false, the challenge controller will not take any more action.
func (o ChallengeStatusPtrOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Processing
	}).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the current state.
func (o ChallengeStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge. If not set, the state of the challenge is unknown.
func (o ChallengeStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderType struct {
	ApiVersion *string           `pulumi:"apiVersion"`
	Kind       *string           `pulumi:"kind"`
	Metadata   metav1.ObjectMeta `pulumi:"metadata"`
	Spec       OrderSpec         `pulumi:"spec"`
	Status     *OrderStatus      `pulumi:"status"`
}

// OrderTypeInput is an input type that accepts OrderTypeArgs and OrderTypeOutput values.
// You can construct a concrete instance of `OrderTypeInput` via:
//
//          OrderTypeArgs{...}
type OrderTypeInput interface {
	pulumi.Input

	ToOrderTypeOutput() OrderTypeOutput
	ToOrderTypeOutputWithContext(context.Context) OrderTypeOutput
}

// Order is a type to represent an Order with an ACME server
type OrderTypeArgs struct {
	ApiVersion pulumi.StringPtrInput  `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput  `pulumi:"kind"`
	Metadata   metav1.ObjectMetaInput `pulumi:"metadata"`
	Spec       OrderSpecInput         `pulumi:"spec"`
	Status     OrderStatusPtrInput    `pulumi:"status"`
}

func (OrderTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderType)(nil)).Elem()
}

func (i OrderTypeArgs) ToOrderTypeOutput() OrderTypeOutput {
	return i.ToOrderTypeOutputWithContext(context.Background())
}

func (i OrderTypeArgs) ToOrderTypeOutputWithContext(ctx context.Context) OrderTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderTypeOutput)
}

// Order is a type to represent an Order with an ACME server
type OrderTypeOutput struct{ *pulumi.OutputState }

func (OrderTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderType)(nil)).Elem()
}

func (o OrderTypeOutput) ToOrderTypeOutput() OrderTypeOutput {
	return o
}

func (o OrderTypeOutput) ToOrderTypeOutputWithContext(ctx context.Context) OrderTypeOutput {
	return o
}

func (o OrderTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o OrderTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o OrderTypeOutput) Metadata() metav1.ObjectMetaOutput {
	return o.ApplyT(func(v OrderType) metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaOutput)
}

func (o OrderTypeOutput) Spec() OrderSpecOutput {
	return o.ApplyT(func(v OrderType) OrderSpec { return v.Spec }).(OrderSpecOutput)
}

func (o OrderTypeOutput) Status() OrderStatusPtrOutput {
	return o.ApplyT(func(v OrderType) *OrderStatus { return v.Status }).(OrderStatusPtrOutput)
}

type OrderMetadata struct {
}

// OrderMetadataInput is an input type that accepts OrderMetadataArgs and OrderMetadataOutput values.
// You can construct a concrete instance of `OrderMetadataInput` via:
//
//          OrderMetadataArgs{...}
type OrderMetadataInput interface {
	pulumi.Input

	ToOrderMetadataOutput() OrderMetadataOutput
	ToOrderMetadataOutputWithContext(context.Context) OrderMetadataOutput
}

type OrderMetadataArgs struct {
}

func (OrderMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderMetadata)(nil)).Elem()
}

func (i OrderMetadataArgs) ToOrderMetadataOutput() OrderMetadataOutput {
	return i.ToOrderMetadataOutputWithContext(context.Background())
}

func (i OrderMetadataArgs) ToOrderMetadataOutputWithContext(ctx context.Context) OrderMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderMetadataOutput)
}

type OrderMetadataOutput struct{ *pulumi.OutputState }

func (OrderMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderMetadata)(nil)).Elem()
}

func (o OrderMetadataOutput) ToOrderMetadataOutput() OrderMetadataOutput {
	return o
}

func (o OrderMetadataOutput) ToOrderMetadataOutputWithContext(ctx context.Context) OrderMetadataOutput {
	return o
}

type OrderSpec struct {
	// CommonName is the common name as specified on the DER encoded CSR. If specified, this value must also be present in `dnsNames`. This field must match the corresponding field on the DER encoded CSR.
	CommonName *string `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR.
	DnsNames []string `pulumi:"dnsNames"`
	// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
	IssuerRef OrderSpecIssuerRef `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding. This will be used when finalizing the order. This field must be set on the order.
	Request string `pulumi:"request"`
}

// OrderSpecInput is an input type that accepts OrderSpecArgs and OrderSpecOutput values.
// You can construct a concrete instance of `OrderSpecInput` via:
//
//          OrderSpecArgs{...}
type OrderSpecInput interface {
	pulumi.Input

	ToOrderSpecOutput() OrderSpecOutput
	ToOrderSpecOutputWithContext(context.Context) OrderSpecOutput
}

type OrderSpecArgs struct {
	// CommonName is the common name as specified on the DER encoded CSR. If specified, this value must also be present in `dnsNames`. This field must match the corresponding field on the DER encoded CSR.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// DNSNames is a list of DNS names that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
	IssuerRef OrderSpecIssuerRefInput `pulumi:"issuerRef"`
	// Certificate signing request bytes in DER encoding. This will be used when finalizing the order. This field must be set on the order.
	Request pulumi.StringInput `pulumi:"request"`
}

func (OrderSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpec)(nil)).Elem()
}

func (i OrderSpecArgs) ToOrderSpecOutput() OrderSpecOutput {
	return i.ToOrderSpecOutputWithContext(context.Background())
}

func (i OrderSpecArgs) ToOrderSpecOutputWithContext(ctx context.Context) OrderSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecOutput)
}

func (i OrderSpecArgs) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return i.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (i OrderSpecArgs) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecOutput).ToOrderSpecPtrOutputWithContext(ctx)
}

// OrderSpecPtrInput is an input type that accepts OrderSpecArgs, OrderSpecPtr and OrderSpecPtrOutput values.
// You can construct a concrete instance of `OrderSpecPtrInput` via:
//
//          OrderSpecArgs{...}
//
//  or:
//
//          nil
type OrderSpecPtrInput interface {
	pulumi.Input

	ToOrderSpecPtrOutput() OrderSpecPtrOutput
	ToOrderSpecPtrOutputWithContext(context.Context) OrderSpecPtrOutput
}

type orderSpecPtrType OrderSpecArgs

func OrderSpecPtr(v *OrderSpecArgs) OrderSpecPtrInput {
	return (*orderSpecPtrType)(v)
}

func (*orderSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpec)(nil)).Elem()
}

func (i *orderSpecPtrType) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return i.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (i *orderSpecPtrType) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecPtrOutput)
}

type OrderSpecOutput struct{ *pulumi.OutputState }

func (OrderSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpec)(nil)).Elem()
}

func (o OrderSpecOutput) ToOrderSpecOutput() OrderSpecOutput {
	return o
}

func (o OrderSpecOutput) ToOrderSpecOutputWithContext(ctx context.Context) OrderSpecOutput {
	return o
}

func (o OrderSpecOutput) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return o.ToOrderSpecPtrOutputWithContext(context.Background())
}

func (o OrderSpecOutput) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return o.ApplyT(func(v OrderSpec) *OrderSpec {
		return &v
	}).(OrderSpecPtrOutput)
}

// CommonName is the common name as specified on the DER encoded CSR. If specified, this value must also be present in `dnsNames`. This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpec) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OrderSpec) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
func (o OrderSpecOutput) IssuerRef() OrderSpecIssuerRefOutput {
	return o.ApplyT(func(v OrderSpec) OrderSpecIssuerRef { return v.IssuerRef }).(OrderSpecIssuerRefOutput)
}

// Certificate signing request bytes in DER encoding. This will be used when finalizing the order. This field must be set on the order.
func (o OrderSpecOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v OrderSpec) string { return v.Request }).(pulumi.StringOutput)
}

type OrderSpecPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpec)(nil)).Elem()
}

func (o OrderSpecPtrOutput) ToOrderSpecPtrOutput() OrderSpecPtrOutput {
	return o
}

func (o OrderSpecPtrOutput) ToOrderSpecPtrOutputWithContext(ctx context.Context) OrderSpecPtrOutput {
	return o
}

func (o OrderSpecPtrOutput) Elem() OrderSpecOutput {
	return o.ApplyT(func(v *OrderSpec) OrderSpec { return *v }).(OrderSpecOutput)
}

// CommonName is the common name as specified on the DER encoded CSR. If specified, this value must also be present in `dnsNames`. This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return v.CommonName
	}).(pulumi.StringPtrOutput)
}

// DNSNames is a list of DNS names that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR.
func (o OrderSpecPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *OrderSpec) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
func (o OrderSpecPtrOutput) IssuerRef() OrderSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *OrderSpecIssuerRef {
		if v == nil {
			return nil
		}
		return &v.IssuerRef
	}).(OrderSpecIssuerRefPtrOutput)
}

// Certificate signing request bytes in DER encoding. This will be used when finalizing the order. This field must be set on the order.
func (o OrderSpecPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Request
	}).(pulumi.StringPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
type OrderSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name string `pulumi:"name"`
}

// OrderSpecIssuerRefInput is an input type that accepts OrderSpecIssuerRefArgs and OrderSpecIssuerRefOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefInput` via:
//
//          OrderSpecIssuerRefArgs{...}
type OrderSpecIssuerRefInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput
	ToOrderSpecIssuerRefOutputWithContext(context.Context) OrderSpecIssuerRefOutput
}

// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
type OrderSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringInput `pulumi:"name"`
}

func (OrderSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRef)(nil)).Elem()
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput {
	return i.ToOrderSpecIssuerRefOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefOutputWithContext(ctx context.Context) OrderSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefOutput)
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return i.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i OrderSpecIssuerRefArgs) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefOutput).ToOrderSpecIssuerRefPtrOutputWithContext(ctx)
}

// OrderSpecIssuerRefPtrInput is an input type that accepts OrderSpecIssuerRefArgs, OrderSpecIssuerRefPtr and OrderSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `OrderSpecIssuerRefPtrInput` via:
//
//          OrderSpecIssuerRefArgs{...}
//
//  or:
//
//          nil
type OrderSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput
	ToOrderSpecIssuerRefPtrOutputWithContext(context.Context) OrderSpecIssuerRefPtrOutput
}

type orderSpecIssuerRefPtrType OrderSpecIssuerRefArgs

func OrderSpecIssuerRefPtr(v *OrderSpecIssuerRefArgs) OrderSpecIssuerRefPtrInput {
	return (*orderSpecIssuerRefPtrType)(v)
}

func (*orderSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRef)(nil)).Elem()
}

func (i *orderSpecIssuerRefPtrType) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return i.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *orderSpecIssuerRefPtrType) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderSpecIssuerRefPtrOutput)
}

// IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an 'ACME' Issuer, an error will be returned and the Order will be marked as failed.
type OrderSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderSpecIssuerRef)(nil)).Elem()
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefOutput() OrderSpecIssuerRefOutput {
	return o
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefOutputWithContext(ctx context.Context) OrderSpecIssuerRefOutput {
	return o
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return o.ToOrderSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o OrderSpecIssuerRefOutput) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *OrderSpecIssuerRef {
		return &v
	}).(OrderSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v OrderSpecIssuerRef) string { return v.Name }).(pulumi.StringOutput)
}

type OrderSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (OrderSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderSpecIssuerRef)(nil)).Elem()
}

func (o OrderSpecIssuerRefPtrOutput) ToOrderSpecIssuerRefPtrOutput() OrderSpecIssuerRefPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPtrOutput) ToOrderSpecIssuerRefPtrOutputWithContext(ctx context.Context) OrderSpecIssuerRefPtrOutput {
	return o
}

func (o OrderSpecIssuerRefPtrOutput) Elem() OrderSpecIssuerRefOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) OrderSpecIssuerRef { return *v }).(OrderSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o OrderSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type OrderStatus struct {
	// Authorizations contains data returned from the ACME server on what authorizations must be completed in order to validate the DNS names specified on the Order.
	Authorizations []OrderStatusAuthorizations `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order. This field will be populated after the order has been successfully finalized with the ACME server, and the order has transitioned to the 'valid' state.
	Certificate *string `pulumi:"certificate"`
	// FailureTime stores the time that this order failed. This is used to influence garbage collection and back-off.
	FailureTime *string `pulumi:"failureTime"`
	// FinalizeURL of the Order. This is used to obtain certificates for this order once it has been completed.
	FinalizeURL *string `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in the current state.
	Reason *string `pulumi:"reason"`
	// State contains the current state of this Order resource. States 'success' and 'expired' are 'final'
	State *string `pulumi:"state"`
	// URL of the Order. This will initially be empty when the resource is first created. The Order controller will populate this field when the Order is first processed. This field will be immutable after it is initially set.
	Url *string `pulumi:"url"`
}

// OrderStatusInput is an input type that accepts OrderStatusArgs and OrderStatusOutput values.
// You can construct a concrete instance of `OrderStatusInput` via:
//
//          OrderStatusArgs{...}
type OrderStatusInput interface {
	pulumi.Input

	ToOrderStatusOutput() OrderStatusOutput
	ToOrderStatusOutputWithContext(context.Context) OrderStatusOutput
}

type OrderStatusArgs struct {
	// Authorizations contains data returned from the ACME server on what authorizations must be completed in order to validate the DNS names specified on the Order.
	Authorizations OrderStatusAuthorizationsArrayInput `pulumi:"authorizations"`
	// Certificate is a copy of the PEM encoded certificate for this Order. This field will be populated after the order has been successfully finalized with the ACME server, and the order has transitioned to the 'valid' state.
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// FailureTime stores the time that this order failed. This is used to influence garbage collection and back-off.
	FailureTime pulumi.StringPtrInput `pulumi:"failureTime"`
	// FinalizeURL of the Order. This is used to obtain certificates for this order once it has been completed.
	FinalizeURL pulumi.StringPtrInput `pulumi:"finalizeURL"`
	// Reason optionally provides more information about a why the order is in the current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// State contains the current state of this Order resource. States 'success' and 'expired' are 'final'
	State pulumi.StringPtrInput `pulumi:"state"`
	// URL of the Order. This will initially be empty when the resource is first created. The Order controller will populate this field when the Order is first processed. This field will be immutable after it is initially set.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (OrderStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatus)(nil)).Elem()
}

func (i OrderStatusArgs) ToOrderStatusOutput() OrderStatusOutput {
	return i.ToOrderStatusOutputWithContext(context.Background())
}

func (i OrderStatusArgs) ToOrderStatusOutputWithContext(ctx context.Context) OrderStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusOutput)
}

func (i OrderStatusArgs) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return i.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (i OrderStatusArgs) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusOutput).ToOrderStatusPtrOutputWithContext(ctx)
}

// OrderStatusPtrInput is an input type that accepts OrderStatusArgs, OrderStatusPtr and OrderStatusPtrOutput values.
// You can construct a concrete instance of `OrderStatusPtrInput` via:
//
//          OrderStatusArgs{...}
//
//  or:
//
//          nil
type OrderStatusPtrInput interface {
	pulumi.Input

	ToOrderStatusPtrOutput() OrderStatusPtrOutput
	ToOrderStatusPtrOutputWithContext(context.Context) OrderStatusPtrOutput
}

type orderStatusPtrType OrderStatusArgs

func OrderStatusPtr(v *OrderStatusArgs) OrderStatusPtrInput {
	return (*orderStatusPtrType)(v)
}

func (*orderStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatus)(nil)).Elem()
}

func (i *orderStatusPtrType) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return i.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (i *orderStatusPtrType) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusPtrOutput)
}

type OrderStatusOutput struct{ *pulumi.OutputState }

func (OrderStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatus)(nil)).Elem()
}

func (o OrderStatusOutput) ToOrderStatusOutput() OrderStatusOutput {
	return o
}

func (o OrderStatusOutput) ToOrderStatusOutputWithContext(ctx context.Context) OrderStatusOutput {
	return o
}

func (o OrderStatusOutput) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return o.ToOrderStatusPtrOutputWithContext(context.Background())
}

func (o OrderStatusOutput) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return o.ApplyT(func(v OrderStatus) *OrderStatus {
		return &v
	}).(OrderStatusPtrOutput)
}

// Authorizations contains data returned from the ACME server on what authorizations must be completed in order to validate the DNS names specified on the Order.
func (o OrderStatusOutput) Authorizations() OrderStatusAuthorizationsArrayOutput {
	return o.ApplyT(func(v OrderStatus) []OrderStatusAuthorizations { return v.Authorizations }).(OrderStatusAuthorizationsArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order. This field will be populated after the order has been successfully finalized with the ACME server, and the order has transitioned to the 'valid' state.
func (o OrderStatusOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed. This is used to influence garbage collection and back-off.
func (o OrderStatusOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.FailureTime }).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order. This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.FinalizeURL }).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in the current state.
func (o OrderStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource. States 'success' and 'expired' are 'final'
func (o OrderStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

// URL of the Order. This will initially be empty when the resource is first created. The Order controller will populate this field when the Order is first processed. This field will be immutable after it is initially set.
func (o OrderStatusOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatus) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type OrderStatusPtrOutput struct{ *pulumi.OutputState }

func (OrderStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OrderStatus)(nil)).Elem()
}

func (o OrderStatusPtrOutput) ToOrderStatusPtrOutput() OrderStatusPtrOutput {
	return o
}

func (o OrderStatusPtrOutput) ToOrderStatusPtrOutputWithContext(ctx context.Context) OrderStatusPtrOutput {
	return o
}

func (o OrderStatusPtrOutput) Elem() OrderStatusOutput {
	return o.ApplyT(func(v *OrderStatus) OrderStatus { return *v }).(OrderStatusOutput)
}

// Authorizations contains data returned from the ACME server on what authorizations must be completed in order to validate the DNS names specified on the Order.
func (o OrderStatusPtrOutput) Authorizations() OrderStatusAuthorizationsArrayOutput {
	return o.ApplyT(func(v *OrderStatus) []OrderStatusAuthorizations {
		if v == nil {
			return nil
		}
		return v.Authorizations
	}).(OrderStatusAuthorizationsArrayOutput)
}

// Certificate is a copy of the PEM encoded certificate for this Order. This field will be populated after the order has been successfully finalized with the ACME server, and the order has transitioned to the 'valid' state.
func (o OrderStatusPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// FailureTime stores the time that this order failed. This is used to influence garbage collection and back-off.
func (o OrderStatusPtrOutput) FailureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.FailureTime
	}).(pulumi.StringPtrOutput)
}

// FinalizeURL of the Order. This is used to obtain certificates for this order once it has been completed.
func (o OrderStatusPtrOutput) FinalizeURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.FinalizeURL
	}).(pulumi.StringPtrOutput)
}

// Reason optionally provides more information about a why the order is in the current state.
func (o OrderStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// State contains the current state of this Order resource. States 'success' and 'expired' are 'final'
func (o OrderStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// URL of the Order. This will initially be empty when the resource is first created. The Order controller will populate this field when the Order is first processed. This field will be immutable after it is initially set.
func (o OrderStatusPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OrderStatus) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an authorization that must be completed in order validate a DNS name on an ACME Order resource.
type OrderStatusAuthorizations struct {
	// Challenges specifies the challenge types offered by the ACME server. One of these challenge types will be selected when validating the DNS name and an appropriate Challenge resource will be created to perform the ACME challenge process.
	Challenges []OrderStatusAuthorizationsChallenges `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier *string `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first fetched from the ACME server. If an Authorization is already 'valid', the Order controller will not create a Challenge resource for the authorization. This will occur when working with an ACME server that enables 'authz reuse' (such as Let's Encrypt's production endpoint). If not set and 'identifier' is set, the state is assumed to be pending and a Challenge will be created.
	InitialState *string `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url string `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name. If this is true, the identifier will be the *non-wildcard* version of the DNS name. For example, if '*.example.com' is the DNS name being validated, this field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// OrderStatusAuthorizationsInput is an input type that accepts OrderStatusAuthorizationsArgs and OrderStatusAuthorizationsOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsInput` via:
//
//          OrderStatusAuthorizationsArgs{...}
type OrderStatusAuthorizationsInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput
	ToOrderStatusAuthorizationsOutputWithContext(context.Context) OrderStatusAuthorizationsOutput
}

// ACMEAuthorization contains data returned from the ACME server on an authorization that must be completed in order validate a DNS name on an ACME Order resource.
type OrderStatusAuthorizationsArgs struct {
	// Challenges specifies the challenge types offered by the ACME server. One of these challenge types will be selected when validating the DNS name and an appropriate Challenge resource will be created to perform the ACME challenge process.
	Challenges OrderStatusAuthorizationsChallengesArrayInput `pulumi:"challenges"`
	// Identifier is the DNS name to be validated as part of this authorization
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
	// InitialState is the initial state of the ACME authorization when first fetched from the ACME server. If an Authorization is already 'valid', the Order controller will not create a Challenge resource for the authorization. This will occur when working with an ACME server that enables 'authz reuse' (such as Let's Encrypt's production endpoint). If not set and 'identifier' is set, the state is assumed to be pending and a Challenge will be created.
	InitialState pulumi.StringPtrInput `pulumi:"initialState"`
	// URL is the URL of the Authorization that must be completed
	Url pulumi.StringInput `pulumi:"url"`
	// Wildcard will be true if this authorization is for a wildcard DNS name. If this is true, the identifier will be the *non-wildcard* version of the DNS name. For example, if '*.example.com' is the DNS name being validated, this field will be 'true' and the 'identifier' field will be 'example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (OrderStatusAuthorizationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizations)(nil)).Elem()
}

func (i OrderStatusAuthorizationsArgs) ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput {
	return i.ToOrderStatusAuthorizationsOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsArgs) ToOrderStatusAuthorizationsOutputWithContext(ctx context.Context) OrderStatusAuthorizationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsOutput)
}

// OrderStatusAuthorizationsArrayInput is an input type that accepts OrderStatusAuthorizationsArray and OrderStatusAuthorizationsArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsArrayInput` via:
//
//          OrderStatusAuthorizationsArray{ OrderStatusAuthorizationsArgs{...} }
type OrderStatusAuthorizationsArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput
	ToOrderStatusAuthorizationsArrayOutputWithContext(context.Context) OrderStatusAuthorizationsArrayOutput
}

type OrderStatusAuthorizationsArray []OrderStatusAuthorizationsInput

func (OrderStatusAuthorizationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizations)(nil)).Elem()
}

func (i OrderStatusAuthorizationsArray) ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput {
	return i.ToOrderStatusAuthorizationsArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsArray) ToOrderStatusAuthorizationsArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsArrayOutput)
}

// ACMEAuthorization contains data returned from the ACME server on an authorization that must be completed in order validate a DNS name on an ACME Order resource.
type OrderStatusAuthorizationsOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizations)(nil)).Elem()
}

func (o OrderStatusAuthorizationsOutput) ToOrderStatusAuthorizationsOutput() OrderStatusAuthorizationsOutput {
	return o
}

func (o OrderStatusAuthorizationsOutput) ToOrderStatusAuthorizationsOutputWithContext(ctx context.Context) OrderStatusAuthorizationsOutput {
	return o
}

// Challenges specifies the challenge types offered by the ACME server. One of these challenge types will be selected when validating the DNS name and an appropriate Challenge resource will be created to perform the ACME challenge process.
func (o OrderStatusAuthorizationsOutput) Challenges() OrderStatusAuthorizationsChallengesArrayOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) []OrderStatusAuthorizationsChallenges { return v.Challenges }).(OrderStatusAuthorizationsChallengesArrayOutput)
}

// Identifier is the DNS name to be validated as part of this authorization
func (o OrderStatusAuthorizationsOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

// InitialState is the initial state of the ACME authorization when first fetched from the ACME server. If an Authorization is already 'valid', the Order controller will not create a Challenge resource for the authorization. This will occur when working with an ACME server that enables 'authz reuse' (such as Let's Encrypt's production endpoint). If not set and 'identifier' is set, the state is assumed to be pending and a Challenge will be created.
func (o OrderStatusAuthorizationsOutput) InitialState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *string { return v.InitialState }).(pulumi.StringPtrOutput)
}

// URL is the URL of the Authorization that must be completed
func (o OrderStatusAuthorizationsOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) string { return v.Url }).(pulumi.StringOutput)
}

// Wildcard will be true if this authorization is for a wildcard DNS name. If this is true, the identifier will be the *non-wildcard* version of the DNS name. For example, if '*.example.com' is the DNS name being validated, this field will be 'true' and the 'identifier' field will be 'example.com'.
func (o OrderStatusAuthorizationsOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OrderStatusAuthorizations) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type OrderStatusAuthorizationsArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizations)(nil)).Elem()
}

func (o OrderStatusAuthorizationsArrayOutput) ToOrderStatusAuthorizationsArrayOutput() OrderStatusAuthorizationsArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsArrayOutput) ToOrderStatusAuthorizationsArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizations {
		return vs[0].([]OrderStatusAuthorizations)[vs[1].(int)]
	}).(OrderStatusAuthorizationsOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order. An appropriate Challenge resource can be created to perform the ACME challenge process.
type OrderStatusAuthorizationsChallenges struct {
	// Token is the token that must be presented for this challenge. This is used to compute the 'key' that must also be presented.
	Token string `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01', 'tls-sni-01', etc. This is the raw value retrieved from the ACME server. Only 'http-01' and 'dns-01' are supported by cert-manager, other values will be ignored.
	Type string `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional metadata about the Challenge from the ACME server.
	Url string `pulumi:"url"`
}

// OrderStatusAuthorizationsChallengesInput is an input type that accepts OrderStatusAuthorizationsChallengesArgs and OrderStatusAuthorizationsChallengesOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesInput` via:
//
//          OrderStatusAuthorizationsChallengesArgs{...}
type OrderStatusAuthorizationsChallengesInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput
	ToOrderStatusAuthorizationsChallengesOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesOutput
}

// Challenge specifies a challenge offered by the ACME server for an Order. An appropriate Challenge resource can be created to perform the ACME challenge process.
type OrderStatusAuthorizationsChallengesArgs struct {
	// Token is the token that must be presented for this challenge. This is used to compute the 'key' that must also be presented.
	Token pulumi.StringInput `pulumi:"token"`
	// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01', 'tls-sni-01', etc. This is the raw value retrieved from the ACME server. Only 'http-01' and 'dns-01' are supported by cert-manager, other values will be ignored.
	Type pulumi.StringInput `pulumi:"type"`
	// URL is the URL of this challenge. It can be used to retrieve additional metadata about the Challenge from the ACME server.
	Url pulumi.StringInput `pulumi:"url"`
}

func (OrderStatusAuthorizationsChallengesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesArgs) ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput {
	return i.ToOrderStatusAuthorizationsChallengesOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesArgs) ToOrderStatusAuthorizationsChallengesOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesOutput)
}

// OrderStatusAuthorizationsChallengesArrayInput is an input type that accepts OrderStatusAuthorizationsChallengesArray and OrderStatusAuthorizationsChallengesArrayOutput values.
// You can construct a concrete instance of `OrderStatusAuthorizationsChallengesArrayInput` via:
//
//          OrderStatusAuthorizationsChallengesArray{ OrderStatusAuthorizationsChallengesArgs{...} }
type OrderStatusAuthorizationsChallengesArrayInput interface {
	pulumi.Input

	ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput
	ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(context.Context) OrderStatusAuthorizationsChallengesArrayOutput
}

type OrderStatusAuthorizationsChallengesArray []OrderStatusAuthorizationsChallengesInput

func (OrderStatusAuthorizationsChallengesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (i OrderStatusAuthorizationsChallengesArray) ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput {
	return i.ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(context.Background())
}

func (i OrderStatusAuthorizationsChallengesArray) ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OrderStatusAuthorizationsChallengesArrayOutput)
}

// Challenge specifies a challenge offered by the ACME server for an Order. An appropriate Challenge resource can be created to perform the ACME challenge process.
type OrderStatusAuthorizationsChallengesOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesOutput) ToOrderStatusAuthorizationsChallengesOutput() OrderStatusAuthorizationsChallengesOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesOutput) ToOrderStatusAuthorizationsChallengesOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesOutput {
	return o
}

// Token is the token that must be presented for this challenge. This is used to compute the 'key' that must also be presented.
func (o OrderStatusAuthorizationsChallengesOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) string { return v.Token }).(pulumi.StringOutput)
}

// Type is the type of challenge being offered, e.g. 'http-01', 'dns-01', 'tls-sni-01', etc. This is the raw value retrieved from the ACME server. Only 'http-01' and 'dns-01' are supported by cert-manager, other values will be ignored.
func (o OrderStatusAuthorizationsChallengesOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) string { return v.Type }).(pulumi.StringOutput)
}

// URL is the URL of this challenge. It can be used to retrieve additional metadata about the Challenge from the ACME server.
func (o OrderStatusAuthorizationsChallengesOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v OrderStatusAuthorizationsChallenges) string { return v.Url }).(pulumi.StringOutput)
}

type OrderStatusAuthorizationsChallengesArrayOutput struct{ *pulumi.OutputState }

func (OrderStatusAuthorizationsChallengesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OrderStatusAuthorizationsChallenges)(nil)).Elem()
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) ToOrderStatusAuthorizationsChallengesArrayOutput() OrderStatusAuthorizationsChallengesArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) ToOrderStatusAuthorizationsChallengesArrayOutputWithContext(ctx context.Context) OrderStatusAuthorizationsChallengesArrayOutput {
	return o
}

func (o OrderStatusAuthorizationsChallengesArrayOutput) Index(i pulumi.IntInput) OrderStatusAuthorizationsChallengesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OrderStatusAuthorizationsChallenges {
		return vs[0].([]OrderStatusAuthorizationsChallenges)[vs[1].(int)]
	}).(OrderStatusAuthorizationsChallengesOutput)
}

func init() {
	pulumi.RegisterOutputType(ChallengeTypeOutput{})
	pulumi.RegisterOutputType(ChallengeMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDNSAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDNSClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDNSServiceAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflarePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(ChallengeStatusOutput{})
	pulumi.RegisterOutputType(ChallengeStatusPtrOutput{})
	pulumi.RegisterOutputType(OrderTypeOutput{})
	pulumi.RegisterOutputType(OrderMetadataOutput{})
	pulumi.RegisterOutputType(OrderSpecOutput{})
	pulumi.RegisterOutputType(OrderSpecPtrOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(OrderSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(OrderStatusOutput{})
	pulumi.RegisterOutputType(OrderStatusPtrOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsArrayOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesOutput{})
	pulumi.RegisterOutputType(OrderStatusAuthorizationsChallengesArrayOutput{})
}
